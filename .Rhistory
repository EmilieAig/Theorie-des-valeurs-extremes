# Fonction A(t) non paramétrique - SA-SB
abvnonpar(data = cbind(maxima_SA, maxima_SB),
plot = TRUE, col = "brown")
abvnonpar(data = cbind(maxima_SA, maxima_SB),
plot = TRUE, method = "pickands", col = "tan", add = TRUE)
legend("bottomright", legend = c("CFG", "Pickands"),
col = c("brown", "tan"), lwd = 2, bty = "n")
title(main = "Estimation non paramétrique de la fonction A(t) - SA et SB")
# Coefficient d'extrémalité
theta_SB <- 2 * abvnonpar(x = 0.5, cbind(maxima_SA, maxima_SB))
cat("Coefficient theta (SA-SB):", theta_SB, "\n")
# Modèles max-stables - SA-SB
modlog_SB  <- fbvevd(cbind(SA_F, SB_F), model = "log")
modalog_SB <- fbvevd(cbind(SA_F, SB_F), model = "alog")
modlog_SB
modalog_SB
# Test de comparaison
anova(modalog_SB, modlog_SB)
# Chi-plot SA-SC
chiplot(cbind(SA_F, SC_F),
main1 = "Chi Plot - SA et SC",
main2 = "Chi Bar Plot - SA et SC")
# Coefficient theta SA-SC
theta_SC <- 2 * abvnonpar(x = 0.5, cbind(SA_F, SC_F))
cat("Coefficient theta (SA-SC):", theta_SC, "\n")
# Modèle logistique
modlog_SC <- fbvevd(cbind(SA_F, SC_F), model = "log")
modlog_SC
# Chi-plot SA-SD
chiplot(cbind(SA_F, SD_F),
main1 = "Chi Plot - SA et SD",
main2 = "Chi Bar Plot - SA et SD")
# Coefficient theta SA-SD
theta_SD <- 2 * abvnonpar(x = 0.5, cbind(SA_F, SD_F))
cat("Coefficient theta (SA-SD):", theta_SD, "\n")
# Modèle logistique
modlog_SD <- fbvevd(cbind(SA_F, SD_F), model = "log")
modlog_SD
# Tableau comparatif
comparaison <- data.frame(
Paire    = c("SA-SB (413 km)", "SA-SC (7 km)", "SA-SD (397 km)"),
gamma_2  = c(gevSB$estimate["shape"],
gevSC$estimate["shape"],
gevSD$estimate["shape"]),
alpha    = c(modlog_SB$estimate["dep"],
modlog_SC$estimate["dep"],
modlog_SD$estimate["dep"]),
theta    = c(theta_SB, theta_SC, theta_SD)
)
print(comparaison)
# Graphique comparatif des fonctions A(t)
abvnonpar(data = cbind(maxima_SA, maxima_SC), plot = TRUE,
col = "lightblue", lwd = 2,
main = "Comparaison des fonctions A(t)")
abvnonpar(data = cbind(maxima_SA, maxima_SB), plot = TRUE,
col = "lightcoral", lwd = 2, add = TRUE)
abvnonpar(data = cbind(maxima_SA, maxima_SD), plot = TRUE,
col = "lightgreen", lwd = 2, add = TRUE)
legend("bottomright",
legend = c("SA-SB", "SA-SC", "SA-SD"),
col    = c("lightcoral", "lightblue", "lightgreen"),
lty = 1, lwd = 2, bty = "n")
# Évolution temporelle des maxima annuels par station
matplot(unique(dates_df_biv$annee),
cbind(maxima_SA, maxima_SB, maxima_SC, maxima_SD),
type = "l", lty = 1, lwd = 2,
col  = c("purple", "lightcoral", "lightblue", "lightgreen"),
xlab = "Année", ylab = "Hauteur maximale (m)",
main = "Évolution des maxima annuels par station")
legend("topright",
legend = c("SA (Lion)", "SB (61010)", "SC (61002)", "SD (61001)"),
col    = c("purple", "lightcoral", "lightblue", "lightgreen"),
lty = 1, lwd = 2)
# Fonction de calcul des quantiles conditionnels
quantile_conditionnel <- function(donnees_Y_brutes, maxima_Y, maxima_X,
gevY, gevX, modlog,
y, p_vals = c(0.01, 0.002, 0.001)) {
# P(Y > y) estimée sur les données horaires brutes
prob_Y <- mean(donnees_Y_brutes > y, na.rm = TRUE)
cat("P(Y >", y, ") =", round(prob_Y, 4), "\n")
# Transformation de y en Fréchet unité
y_F <- evd::qgev(evd::pgev(y,
loc   = gevY$estimate["loc"],
scale = gevY$estimate["scale"],
shape = gevY$estimate["shape"]),
loc = 1, scale = 1, shape = 1)
alpha_dep <- modlog$estimate["dep"]
resultats <- data.frame(p = p_vals, z_p = NA,
periode_retour = c("100 ans", "500 ans", "1000 ans"))
for (i in seq_along(p_vals)) {
p <- p_vals[i]
prob_jointe <- p * prob_Y
f_obj <- function(z_F) {
if (z_F <= 0) return(1)
copule <- exp(-((1/z_F)^(1/alpha_dep) + (1/y_F)^(1/alpha_dep))^alpha_dep)
survie_jointe <- 1 - exp(-1/z_F) - exp(-1/y_F) + copule
return(abs(survie_jointe - prob_jointe))
}
opt   <- optimize(f_obj, interval = c(1e-6, 1e6))
z_p_F <- opt$minimum
# Retransformation vers l'échelle originale
z_p <- evd::qgev(evd::pgev(z_p_F, loc = 1, scale = 1, shape = 1),
loc   = gevX$estimate["loc"],
scale = gevX$estimate["scale"],
shape = gevX$estimate["shape"])
resultats$z_p[i] <- round(z_p, 3)
}
return(resultats)
}
# Application aux trois paires
cat("\n=== Paire SA-SB (413 km) ===\n")
res_SB <- quantile_conditionnel(donneesVague$station1, maxima_SA, maxima_SB,
gevSA, gevSB, modlog_SB, y = 4)
print(res_SB)
cat("\n=== Paire SA-SC (7 km) ===\n")
res_SC <- quantile_conditionnel(donneesVague$station1, maxima_SA, maxima_SC,
gevSA, gevSC, modlog_SC, y = 4)
print(res_SC)
cat("\n=== Paire SA-SD (397 km) ===\n")
res_SD <- quantile_conditionnel(donneesVague$station1, maxima_SA, maxima_SD,
gevSA, gevSD, modlog_SD, y = 4)
print(res_SD)
# Chargement des données
load("data/DonneesStations.RData")
load("data/DonneesVagues.RData")
# Chargement des données
load("data\DonneesStations.RData")
load("data\DonneesVagues.RData")
# Chargement des données
load("data/DonneesStations.RData")
load("data/DonneesVagues.RData")
setwd("~/Desktop/Theorie-des-valeurs-extremes")
# Chargement des données
load("data/DonneesStations.RData")
load("data/DonneesVagues.RData")
# Chargement des packages
library(ggplot2)    # Graphiques
library(ggrepel)    # Étiquettes non-superposées
library(lubridate)  # Manipulation de dates
library(dplyr)      # Transformation de données
library(evd)        # Valeurs extrêmes bivariées
library(extRemes)   # Diagnostics valeurs extrêmes
library(ismev)      # Ajustement GEV/GPD/PP
# Chargement des données
load("data/DonneesStations.RData")
load("data/DonneesVagues.RData")
# Préparation des données avec catégorie de station (intérêt ou autre)
station_interet <- buoysInfos %>%
mutate(categorie = case_when(
indexStation == 1 ~ "Station SA",
indexStation == 11 ~ "Station SB",
indexStation == 8 ~ "Station SC",
indexStation == 7 ~ "Station SD",
TRUE ~ "Autres stations"
)
)
# Définition des couleurs
couleurs <- c(
"Station SA" = "plum",
"Station SB" = "lightcoral",
"Station SC" = "lightblue",
"Station SD" = "lightgreen",
"Autres stations" = "darkblue"
)
# Graphique pour la répartition des stations
carte_stations <- ggplot(station_interet,
aes(x = lon, y = lat, color = categorie)) +
geom_point(size = 4) +
geom_text_repel(aes(label = indexStation), size = 3,
box.padding = 0.5, point.padding = 0.3,
color = "black",
show.legend = FALSE) +
scale_color_manual(values = couleurs) +
labs(title = "Localisation des 20 stations dans le golfe du Lion",
x = "Longitude", y = "Latitude",
color = "") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5),
legend.position = "bottom")
print(carte_stations)
# Série temporelle de la station Lion (station 1)
dates <- as.POSIXct(donneesVague$date)
hauteurs_lion <- donneesVague$station1
# Graphique de la série temporelle complète
serie_lion <- ggplot(data.frame(date = dates, hauteur = hauteurs_lion),
aes(x = date, y = hauteur)) +
geom_line(color = "darkblue", linewidth = 0.3) +
labs(title = "Hauteurs de vagues - Station Lion (1961-2012)",
x = "Date", y = "Hauteur significative (m)") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
print(serie_lion)
# Zoom sur 2 années (2010-2011) pour observer les tendances saisonnières
dates_zoom <- dates >= as.POSIXct("2010-01-01") & dates < as.POSIXct("2012-01-01")
donnees_zoom <- data.frame(date = dates[dates_zoom],
hauteur = hauteurs_lion[dates_zoom])
serie_lion_zoom <- ggplot(donnees_zoom, aes(x = date, y = hauteur)) +
geom_line(color = "darkblue", linewidth = 0.5) +
labs(title = "Hauteurs de vagues - Station Lion (2010-2011)",
x = "Date", y = "Hauteur significative (m)") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
print(serie_lion_zoom)
# Statistiques descriptives pour la station Lion
cat("Nombre d'observations:", length(hauteurs_lion), "\n")
cat("Minimum:", min(hauteurs_lion, na.rm = TRUE), "m\n")
cat("Maximum:", max(hauteurs_lion, na.rm = TRUE), "m\n")
cat("Moyenne:", round(mean(hauteurs_lion, na.rm = TRUE), 3), "m\n")
cat("Médiane:", round(median(hauteurs_lion, na.rm = TRUE), 3), "m\n")
cat("Écart-type:", round(sd(hauteurs_lion, na.rm = TRUE), 3), "m\n")
cat("Nombre de valeurs manquantes:", sum(is.na(hauteurs_lion)), "\n")
# Distribution des hauteurs de vagues
hist_lion <- ggplot(data.frame(hauteur = hauteurs_lion), aes(x = hauteur)) +
geom_histogram(bins = 50, fill = "plum", color = "black", alpha = 0.7) +
labs(title = "Distribution des hauteurs de vagues - Station Lion",
x = "Hauteur significative (m)", y = "Fréquence") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
print(hist_lion)
# Extraction des maxima mensuels
dates_df <- data.frame(
date   = dates,
hauteur = hauteurs_lion,
annee  = year(dates),
mois   = month(dates)
)
maxima_mensuels <- aggregate(hauteur ~ annee + mois,
data = dates_df,
FUN = max)
# Test de stationnarité : évolution des maxima mensuels dans le temps
plot(maxima_mensuels$hauteur,
type = "l",
main = "Évolution des maxima mensuels dans le temps",
xlab = "Indice temporel (mois)",
ylab = "Hauteur maximale (m)",
col = "darkblue")
abline(h = mean(maxima_mensuels$hauteur), col = "red", lty = 2)
# Test d'indépendance : autocorrélation des maxima mensuels
acf(maxima_mensuels$hauteur,
main = "Fonction d'autocorrélation des maxima mensuels")
# Préparation des données de la station Lion
X <- donneesVague %>% select(c(date, station1))
# Vérification des doublons
length(unique(X$date))
# Garder l'ordre des dates
X <- X[order(X$date), ]
# Supprimer les doublons
X <- X[!duplicated(X$date), ]
# Nombre de points par an (données horaires)
npp <- 8760
# p pour les différentes périodes de retour
p_100  <- 1 / (100  * npp)
p_500  <- 1 / (500  * npp)
p_1000 <- 1 / (1000 * npp)
# Calcul des maxima par bloc (mois, saison, année)
# Maxima mensuels (~732h par mois)
maxX <- rep(0, 624)
for (i in 1:624) {
maxX[i] <- max(X$station1[((i - 1) * 732 + 1):(i * 732)])
}
# Maxima saisonniers (~2196h par saison)
maxX1 <- rep(0, 208)
for (i in 1:208) {
maxX1[i] <- max(X$station1[((i - 1) * 2196 + 1):(i * 2196)])
}
# Maxima annuels (~8760h par an)
maxX2 <- rep(0, 52)
for (i in 1:52) {
maxX2[i] <- max(X$station1[((i - 1) * 8760 + 1):(i * 8760)])
}
# Visualisation des maxima par bloc
ggplot(data.frame(index = seq_along(maxX), max = maxX), aes(x = index, y = max)) +
geom_point(color = "black", size = 0.8) +
labs(title = "Max mensuels", x = "Index", y = "Max station1") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
ggplot(data.frame(index = seq_along(maxX1), max = maxX1), aes(x = index, y = max)) +
geom_point(color = "red", size = 0.8) +
labs(title = "Max saisonniers", x = "Index", y = "Max station1") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
ggplot(data.frame(index = seq_along(maxX2), max = maxX2), aes(x = index, y = max)) +
geom_point(color = "blue", size = 0.8) +
labs(title = "Max annuels", x = "Index", y = "Max station1") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
# Ajustement GEV sur les maxima annuels
dataGEV <- gev.fit(maxX2)
# Intervalles de confiance à 95%
dataGEV$mle - 1.96 * dataGEV$se
dataGEV$mle + 1.96 * dataGEV$se
# Diagnostics graphiques
gev.diag(dataGEV)
# Niveaux de retour GEV (100, 500, 1000 ans)
ypm1   <- -log((1 - p_100)  ^ npp)
zp_100 <- dataGEV$mle[1] - (dataGEV$mle[2] / dataGEV$mle[3]) * (1 - ypm1 ^ (-dataGEV$mle[3]))
ypm1   <- -log((1 - p_500)  ^ npp)
zp_500 <- dataGEV$mle[1] - (dataGEV$mle[2] / dataGEV$mle[3]) * (1 - ypm1 ^ (-dataGEV$mle[3]))
ypm1    <- -log((1 - p_1000) ^ npp)
zp_1000 <- dataGEV$mle[1] - (dataGEV$mle[2] / dataGEV$mle[3]) * (1 - ypm1 ^ (-dataGEV$mle[3]))
cat("Niveau de retour 100 ans (GEV) :", round(zp_100,  3), "m\n")
cat("Niveau de retour 500 ans (GEV) :", round(zp_500,  3), "m\n")
cat("Niveau de retour 1000 ans (GEV):", round(zp_1000, 3), "m\n")
# Mean Residual Life Plot pour le choix du seuil
mrlplot(X$station1)
# Ajustement GPD avec seuil u = 4.5
VaRGPD_100  <- fpot(X$station1, 4.5, npp = npp, mper = 100)
VaRGPD_500  <- fpot(X$station1, 4.5, npp = npp, mper = 500)
VaRGPD_1000 <- fpot(X$station1, 4.5, npp = npp, mper = 1000)
# Diagnostics graphiques
par(mfrow = c(2, 2))
plot(VaRGPD_100)
# Résumés
VaRGPD_100
VaRGPD_500
VaRGPD_1000
# Ajustement PP avec maxima annuels et seuil
seuil_pp <- 4.5
PPFit <- pp.fit(xdat = X$station1, udat = maxX2, threshold = seuil_pp, npp = npp)
summary(PPFit)
# Niveaux de retour PP (100, 500, 1000 ans)
pp_loc   <- PPFit$mle[1]
pp_scale <- PPFit$mle[2]
pp_shape <- PPFit$mle[3]
pp_100  <- qgev(1 - 1/100,  loc = pp_loc, scale = pp_scale, shape = pp_shape)
pp_500  <- qgev(1 - 1/500,  loc = pp_loc, scale = pp_scale, shape = pp_shape)
pp_1000 <- qgev(1 - 1/1000, loc = pp_loc, scale = pp_scale, shape = pp_shape)
cat("Niveau de retour 100 ans (PP) :", round(pp_100,  3), "m\n")
cat("Niveau de retour 500 ans (PP) :", round(pp_500,  3), "m\n")
cat("Niveau de retour 1000 ans (PP):", round(pp_1000, 3), "m\n")
# Diagnostics graphiques
pp.diag(PPFit)
# Extraction des maxima annuels pour toutes les stations
dates_df_biv <- data.frame(
date  = dates,
SA    = donneesVague$station1,
SB    = donneesVague$station9,
SC    = donneesVague$station6,
SD    = donneesVague$station5,
annee = year(dates)
)
maxima_SA <- aggregate(SA ~ annee, data = dates_df_biv, FUN = max)$SA
maxima_SB <- aggregate(SB ~ annee, data = dates_df_biv, FUN = max)$SB
maxima_SC <- aggregate(SC ~ annee, data = dates_df_biv, FUN = max)$SC
maxima_SD <- aggregate(SD ~ annee, data = dates_df_biv, FUN = max)$SD
cat("Nombre de maxima annuels:", length(maxima_SA), "\n")
# Ajustement GEV sur les maxima annuels de chaque station
gevSA <- fgev(maxima_SA)
gevSB <- fgev(maxima_SB)
gevSC <- fgev(maxima_SC)
gevSD <- fgev(maxima_SD)
gevSA
gevSB
gevSC
gevSD
# Transformation en marginales Fréchet unité
SA_F <- evd::qgev(evd::pgev(maxima_SA,
loc   = gevSA$estimate["loc"],
scale = gevSA$estimate["scale"],
shape = gevSA$estimate["shape"]),
loc = 1, scale = 1, shape = 1)
SB_F <- evd::qgev(evd::pgev(maxima_SB,
loc   = gevSB$estimate["loc"],
scale = gevSB$estimate["scale"],
shape = gevSB$estimate["shape"]),
loc = 1, scale = 1, shape = 1)
SC_F <- evd::qgev(evd::pgev(maxima_SC,
loc   = gevSC$estimate["loc"],
scale = gevSC$estimate["scale"],
shape = gevSC$estimate["shape"]),
loc = 1, scale = 1, shape = 1)
SD_F <- evd::qgev(evd::pgev(maxima_SD,
loc   = gevSD$estimate["loc"],
scale = gevSD$estimate["scale"],
shape = gevSD$estimate["shape"]),
loc = 1, scale = 1, shape = 1)
# Nuage de points SA-SB transformé en Fréchet unité
plot(SA_F, SB_F,
main = "Données transformées en Fréchet unité - SA et SB",
xlab = "SA - Fréchet(1,1,1)",
ylab = "SB - Fréchet(1,1,1)",
col  = "darkblue")
# Chi-plot SA-SB
chiplot(cbind(maxima_SA, maxima_SB),
main1 = "Chi Plot - SA et SB",
main2 = "Chi Bar Plot - SA et SB")
# Fonction A(t) non paramétrique - SA-SB
abvnonpar(data = cbind(maxima_SA, maxima_SB),
plot = TRUE, col = "brown")
abvnonpar(data = cbind(maxima_SA, maxima_SB),
plot = TRUE, method = "pickands", col = "tan", add = TRUE)
legend("bottomright", legend = c("CFG", "Pickands"),
col = c("brown", "tan"), lwd = 2, bty = "n")
title(main = "Estimation non paramétrique de la fonction A(t) - SA et SB")
# Coefficient d'extrémalité
theta_SB <- 2 * abvnonpar(x = 0.5, cbind(maxima_SA, maxima_SB))
cat("Coefficient theta (SA-SB):", theta_SB, "\n")
# Modèles max-stables - SA-SB
modlog_SB  <- fbvevd(cbind(SA_F, SB_F), model = "log")
modalog_SB <- fbvevd(cbind(SA_F, SB_F), model = "alog")
modlog_SB
modalog_SB
# Test de comparaison
anova(modalog_SB, modlog_SB)
# Chi-plot SA-SC
chiplot(cbind(SA_F, SC_F),
main1 = "Chi Plot - SA et SC",
main2 = "Chi Bar Plot - SA et SC")
# Coefficient theta SA-SC
theta_SC <- 2 * abvnonpar(x = 0.5, cbind(SA_F, SC_F))
cat("Coefficient theta (SA-SC):", theta_SC, "\n")
# Modèle logistique
modlog_SC <- fbvevd(cbind(SA_F, SC_F), model = "log")
modlog_SC
# Chi-plot SA-SD
chiplot(cbind(SA_F, SD_F),
main1 = "Chi Plot - SA et SD",
main2 = "Chi Bar Plot - SA et SD")
# Coefficient theta SA-SD
theta_SD <- 2 * abvnonpar(x = 0.5, cbind(SA_F, SD_F))
cat("Coefficient theta (SA-SD):", theta_SD, "\n")
# Modèle logistique
modlog_SD <- fbvevd(cbind(SA_F, SD_F), model = "log")
modlog_SD
# Tableau comparatif
comparaison <- data.frame(
Paire    = c("SA-SB (413 km)", "SA-SC (7 km)", "SA-SD (397 km)"),
gamma_2  = c(gevSB$estimate["shape"],
gevSC$estimate["shape"],
gevSD$estimate["shape"]),
alpha    = c(modlog_SB$estimate["dep"],
modlog_SC$estimate["dep"],
modlog_SD$estimate["dep"]),
theta    = c(theta_SB, theta_SC, theta_SD)
)
print(comparaison)
# Graphique comparatif des fonctions A(t)
abvnonpar(data = cbind(maxima_SA, maxima_SC), plot = TRUE,
col = "lightblue", lwd = 2,
main = "Comparaison des fonctions A(t)")
abvnonpar(data = cbind(maxima_SA, maxima_SB), plot = TRUE,
col = "lightcoral", lwd = 2, add = TRUE)
abvnonpar(data = cbind(maxima_SA, maxima_SD), plot = TRUE,
col = "lightgreen", lwd = 2, add = TRUE)
legend("bottomright",
legend = c("SA-SB", "SA-SC", "SA-SD"),
col    = c("lightcoral", "lightblue", "lightgreen"),
lty = 1, lwd = 2, bty = "n")
# Évolution temporelle des maxima annuels par station
matplot(unique(dates_df_biv$annee),
cbind(maxima_SA, maxima_SB, maxima_SC, maxima_SD),
type = "l", lty = 1, lwd = 2,
col  = c("purple", "lightcoral", "lightblue", "lightgreen"),
xlab = "Année", ylab = "Hauteur maximale (m)",
main = "Évolution des maxima annuels par station")
legend("topright",
legend = c("SA (Lion)", "SB (61010)", "SC (61002)", "SD (61001)"),
col    = c("purple", "lightcoral", "lightblue", "lightgreen"),
lty = 1, lwd = 2)
# Fonction de calcul des quantiles conditionnels
quantile_conditionnel <- function(donnees_Y_brutes, maxima_Y, maxima_X,
gevY, gevX, modlog,
y, p_vals = c(0.01, 0.002, 0.001)) {
# P(Y > y) estimée sur les données horaires brutes
prob_Y <- mean(donnees_Y_brutes > y, na.rm = TRUE)
cat("P(Y >", y, ") =", round(prob_Y, 4), "\n")
# Transformation de y en Fréchet unité
y_F <- evd::qgev(evd::pgev(y,
loc   = gevY$estimate["loc"],
scale = gevY$estimate["scale"],
shape = gevY$estimate["shape"]),
loc = 1, scale = 1, shape = 1)
alpha_dep <- modlog$estimate["dep"]
resultats <- data.frame(p = p_vals, z_p = NA,
periode_retour = c("100 ans", "500 ans", "1000 ans"))
for (i in seq_along(p_vals)) {
p <- p_vals[i]
prob_jointe <- p * prob_Y
f_obj <- function(z_F) {
if (z_F <= 0) return(1)
copule <- exp(-((1/z_F)^(1/alpha_dep) + (1/y_F)^(1/alpha_dep))^alpha_dep)
survie_jointe <- 1 - exp(-1/z_F) - exp(-1/y_F) + copule
return(abs(survie_jointe - prob_jointe))
}
opt   <- optimize(f_obj, interval = c(1e-6, 1e6))
z_p_F <- opt$minimum
# Retransformation vers l'échelle originale
z_p <- evd::qgev(evd::pgev(z_p_F, loc = 1, scale = 1, shape = 1),
loc   = gevX$estimate["loc"],
scale = gevX$estimate["scale"],
shape = gevX$estimate["shape"])
resultats$z_p[i] <- round(z_p, 3)
}
return(resultats)
}
# Application aux trois paires
cat("\n=== Paire SA-SB (413 km) ===\n")
res_SB <- quantile_conditionnel(donneesVague$station1, maxima_SA, maxima_SB,
gevSA, gevSB, modlog_SB, y = 4)
print(res_SB)
cat("\n=== Paire SA-SC (7 km) ===\n")
res_SC <- quantile_conditionnel(donneesVague$station1, maxima_SA, maxima_SC,
gevSA, gevSC, modlog_SC, y = 4)
print(res_SC)
cat("\n=== Paire SA-SD (397 km) ===\n")
res_SD <- quantile_conditionnel(donneesVague$station1, maxima_SA, maxima_SD,
gevSA, gevSD, modlog_SD, y = 4)
print(res_SD)
# Mean Residual Life Plot pour le choix du seuil
mrlplot(X$station1, main = "titre")
# Mean Residual Life Plot pour le choix du seuil
mrlplot(X$station1, main = "Mean Residual Life Plot")
